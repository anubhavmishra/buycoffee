package main

import (
	"encoding/json"
	"fmt"
	"html/template"
	"io/ioutil"
	"log"
	"net/http"
	"os"

	"github.com/gobuffalo/packr"
)

type TemplateData struct {
	StoreInventory      []InventoryItem
	UnderTheHoodComment template.HTML
	ErrorMessage        string
}

type StoreInventory struct {
	Inventory []InventoryItem `json:"inventory"`
}

type InventoryItem struct {
	ID       int     `json:"id"`
	Name     string  `json:"name"`
	ImageURL string  `json:"image_url"`
	Price    float32 `json:"price"`
	Currency string  `json:"currency"`
}

var box = packr.NewBox("./templates")

const comment = `<!--

Hello there, You seem curious about what's under the hood of this amazing webpage.
This page is generated by a technology called "over-engineering". It uses serverless platform to run and golang 
to generate server-side HTML seen on this page.

-->`

var inventoryServiceAddress = os.Getenv("INVENTORY_SERVICE_ADDR")

// serviceName is the name of the service provided by the
// runtime environment
var serviceName = os.Getenv("SERVICE_NAME")

func main() {
	log.Println("Starting buycoffee app.....")

	// validate environment variables
	if serviceName == "" {
		serviceName = "buycoffee-frontend"
	}

	if inventoryServiceAddress == "" {
		inventoryServiceAddress = "localhost:8081"
	}

	log.Printf("Service Name: %q, Inventory Service Address: %q, Order Service Address: %q",
		serviceName, inventoryServiceAddress, "")

	fs := packr.NewBox("./static")
	http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(fs)))

	http.HandleFunc("/", HandleTemplate)

	log.Println("Listening on port 8080...")
	http.ListenAndServe(":8080", nil)
}

func HandleTemplate(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}

	html, _ := box.FindString("index.html")

	tmpl := template.New("index")

	//lp := filepath.Join("templates", "index.html")

	tmpl, err := tmpl.Parse(html)
	if err != nil {
		// Log the detailed error
		log.Println(err.Error())
		// Return a generic "Internal Server Error" message
		http.Error(w, http.StatusText(500), 500)
		return
	}

	inventory, err := getInventory()
	var errMessage string
	if err != nil {
		log.Println(err.Error())
		errMessage = "Inventory isn't available! Please try again later. â˜•"
	}

	var storeInventory StoreInventory
	if errMessage == "" {
		storeInventory = *inventory
	}

	if err := tmpl.Execute(w, TemplateData{StoreInventory: storeInventory.Inventory, ErrorMessage: errMessage, UnderTheHoodComment: template.HTML(comment)}); err != nil {
		log.Println(err.Error())
		http.Error(w, http.StatusText(500), 500)
	}
}

func getInventory() (*StoreInventory, error) {
	log.Printf("requesting inventory from %s\n", inventoryServiceAddress)

	client := &http.Client{}
	req, err := http.NewRequest("GET", fmt.Sprintf("http://%s/inventory", inventoryServiceAddress), nil)
	if err != nil {
		return nil, err
	}

	req.Header.Add("X-Service-ID", serviceName)

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var s = StoreInventory{}

	err = json.Unmarshal(body, &s)
	if err != nil {
		return nil, err
	}

	return &s, nil
}
